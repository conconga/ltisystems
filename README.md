-   [<span class="toc-section-number">1</span>
    Introduction](#introduction)
-   [<span class="toc-section-number">2</span> Classes](#classes)
    -   [<span class="toc-section-number">2.1</span>
        k2OrderLTIsysSiso](#k2orderltisyssiso)
        -   [<span class="toc-section-number">2.1.1</span> to create a
            SISO continuous 2-order LTI
            system:](#to-create-a-siso-continuous-2-order-lti-system)
        -   [<span class="toc-section-number">2.1.2</span> to create a
            SISO discrete 2-order LTI
            system:](#to-create-a-siso-discrete-2-order-lti-system)
        -   [<span class="toc-section-number">2.1.3</span> to update the
            systems:](#to-update-the-systems)
        -   [<span class="toc-section-number">2.1.4</span> to get the
            current state:](#to-get-the-current-state)
    -   [<span class="toc-section-number">2.2</span>
        k2OrderLTIsysMimo](#k2orderltisysmimo)
        -   [<span class="toc-section-number">2.2.1</span> to create a
            MIMO continuous 2-order LTI
            system:](#to-create-a-mimo-continuous-2-order-lti-system)
        -   [<span class="toc-section-number">2.2.2</span> to create a
            MIMO discrete 2-order LTI
            system:](#to-create-a-mimo-discrete-2-order-lti-system)
        -   [<span class="toc-section-number">2.2.3</span> to update the
            systems:](#to-update-the-systems-1)
        -   [<span class="toc-section-number">2.2.4</span> to get the
            current state:](#to-get-the-current-state-1)
    -   [<span class="toc-section-number">2.3</span>
        kNOrderDerivativeSiso](#knorderderivativesiso)
        -   [<span class="toc-section-number">2.3.1</span> to create a
            system (filter):](#to-create-a-system-filter)
        -   [<span class="toc-section-number">2.3.2</span> to update the
            inputs and get new
            outputs:](#to-update-the-inputs-and-get-new-outputs)
-   [<span class="toc-section-number">3</span> How to use](#how-to-use)

# Introduction

This package contains filters to calculate the derivative of stochastic
signals. The 2-order filters allow to limit (up and down) both the
output and slopes. The N-order filter allow to estimate the derivative
of any order fo the input signal.

| type | description                      |
|:----:|:---------------------------------|
| SISO | Single-Input / Single-Output     |
| MIMO | Multiple-Input / Multiple-Output |

# Classes

![classes.png](classes.png?raw=true "UML generated by pyreverse")

## k2OrderLTIsysSiso

### to create a SISO continuous 2-order LTI system:

        qsi      : damping factor        
        wn       : [rad/s] natural freq.
        x0       : initial state : scalar or 2D
        min_dxdt : min rate slope
        max_dxdt : max rate slope
        min_x    : min output   
        max_x    : max output  

        lti_continuous = k2OrderLTIsysSiso (self, qsi, wn, x0, min_dxdt, max_dxdt, min_x, max_x, Ts=0)

### to create a SISO discrete 2-order LTI system:

        qsi      : damping factor        
        wn       : [rad/s] natural freq.
        x0       : initial state : scalar or 2D
        min_dxdt : min rate slope
        max_dxdt : max rate slope
        min_x    : min output   
        max_x    : max output  
        Ts       : sampling frequency

        lti_discrete = k2OrderLTIsysSiso (self, qsi, wn, x0, min_dxdt, max_dxdt, min_x, max_x, Ts=Ts)

### to update the systems:

        t : update up to this time (only continuous, not used for the discrete)
        u : input of the system

        lti_continuous.update(t,u)
        lti_discrete.update(t,u)

### to get the current state:

        out, dout_dt = lti.get_state()

## k2OrderLTIsysMimo

### to create a MIMO continuous 2-order LTI system:

        qsi      : damping factor         : scalar
        wn       : [rad/s] natural freq.  : scalar
        x0       : initial state          : N=len(x0) is the length of inputs and outputs of the MIMO system
        min_dxdt : min rate slope         : scalar, list[N], vector[N]
        max_dxdt : max rate slope         : scalar, list[N], vector[N]
        min_x    : min output             : scalar, list[N], vector[N]
        max_x    : max output             : scalar, list[N], vector[N]

        ltimimo_continuous = k2OrderLTIsysMimo (self, qsi, wn, x0, min_dxdt, max_dxdt, min_x, max_x, Ts=0)

### to create a MIMO discrete 2-order LTI system:

        qsi      : damping factor         : scalar
        wn       : [rad/s] natural freq.  : scalar
        x0       : initial state          : N=len(x0) is the length of inputs and outputs of the MIMO system
        min_dxdt : min rate slope         : scalar, list[N], vector[N]
        max_dxdt : max rate slope         : scalar, list[N], vector[N]
        min_x    : min output             : scalar, list[N], vector[N]
        max_x    : max output             : scalar, list[N], vector[N]
        Ts       : sampling frequency

        ltimimo_discrete = k2OrderLTIsysMimo (self, qsi, wn, x0, min_dxdt, max_dxdt, min_x, max_x, Ts=Ts)

### to update the systems:

        t : update up to this time (only continuous, not used for the discrete)
        u : input of the system

        ltimimo_continuous.update(t,u)
        ltimimo_discrete.update(t,u)

### to get the current state:

        out, dout_dt = lti.get_state()

## kNOrderDerivativeSiso

### to create a system (filter):

        order =    4 # when we want y, y', y", y'", y""
        pole  = -100 # fast and stable
        Ts    =  0.1 # [s]
        obj   = kNOrderDerivativeSiso( order, pole, Ts )

### to update the inputs and get new outputs:

        out     = obj.update(0.7)
        y       = out[0]
        dydt    = out[1]
        ...
        d4y/dt4 = out[4]

# How to use

        import sys
        sys.path.append(< up to where folder kltisystems is >)
        from kltisystems import k2OrderLTIsysSiso, k2OrderLTIsysMimo, kNOrderDerivativeSiso
